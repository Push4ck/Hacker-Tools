#!/usr/bin/env python3
"""
Sentinex - Advanced Malware Detection Scanner
A professional command-line malware detection tool using cryptographic hashing
"""

import os
import sys
import time
import json
import hashlib
import logging
import argparse
import threading
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Set, Optional, Tuple
from concurrent.futures import ThreadPoolExecutor, as_completed


# Configuration
VERSION = "2.0.0"
AUTHOR = "Sentinex Security Team"
DEFAULT_LOG_FILE = "Sentinex.log"
DEFAULT_REPORT_FILE = "scan_report.json"
HASH_DATABASE_FILE = "malware_hashes.json"

# ANSI Color Codes
class Colors:
    """ANSI color codes for terminal styling"""
    RESET = '\033[0m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    UNDERLINE = '\033[4m'
    
    # Text colors
    BLACK = '\033[30m'
    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    MAGENTA = '\033[35m'
    CYAN = '\033[36m'
    WHITE = '\033[37m'
    
    # Bright colors
    BRIGHT_RED = '\033[91m'
    BRIGHT_GREEN = '\033[92m'
    BRIGHT_YELLOW = '\033[93m'
    BRIGHT_BLUE = '\033[94m'
    BRIGHT_MAGENTA = '\033[95m'
    BRIGHT_CYAN = '\033[96m'
    BRIGHT_WHITE = '\033[97m'
    
    # Background colors
    BG_RED = '\033[41m'
    BG_GREEN = '\033[42m'
    BG_YELLOW = '\033[43m'


def colorize(text: str, color: str = "") -> str:
    """Apply color to text if terminal supports it"""
    if os.getenv('NO_COLOR') or not sys.stdout.isatty():
        return text
    return f"{color}{text}{Colors.RESET}"


class ProgressBar:
    """Simple progress bar for file scanning"""
    
    def __init__(self, total: int, width: int = 50):
        self.total = total
        self.current = 0
        self.width = width
        self.start_time = time.time()
        
    def update(self, increment: int = 1):
        """Update progress bar"""
        self.current += increment
        if self.current > self.total:
            self.current = self.total
            
        percent = (self.current / self.total) * 100 if self.total > 0 else 100
        filled = int(self.width * self.current // self.total) if self.total > 0 else self.width
        bar = '█' * filled + '░' * (self.width - filled)
        
        elapsed = time.time() - self.start_time
        rate = self.current / elapsed if elapsed > 0 else 0
        
        sys.stdout.write(f'\r{colorize("Scanning:", Colors.CYAN)} [{colorize(bar, Colors.BRIGHT_BLUE)}] {percent:.1f}% ({self.current}/{self.total}) - {rate:.1f} files/sec')
        sys.stdout.flush()
        
        if self.current >= self.total:
            print()  # New line when complete


class ScanResults:
    """Container for scan results and statistics"""
    
    def __init__(self):
        self.total_files = 0
        self.scanned_files = 0
        self.clean_files = 0
        self.infected_files = 0
        self.skipped_files = 0
        self.errors = 0
        self.start_time = None
        self.end_time = None
        self.malware_detections: List[Dict] = []
        self.scan_errors: List[Dict] = []
        
    def add_detection(self, file_path: str, hash_value: str, hash_type: str, threat_name: str = "Unknown"):
        """Add malware detection"""
        self.malware_detections.append({
            'file_path': str(file_path),
            'hash': hash_value,
            'hash_type': hash_type,
            'threat_name': threat_name,
            'timestamp': datetime.now().isoformat()
        })
        self.infected_files += 1
        
    def add_error(self, file_path: str, error_msg: str):
        """Add scan error"""
        self.scan_errors.append({
            'file_path': str(file_path),
            'error': error_msg,
            'timestamp': datetime.now().isoformat()
        })
        self.errors += 1
        
    def get_duration(self) -> float:
        """Get scan duration in seconds"""
        if self.start_time and self.end_time:
            return (self.end_time - self.start_time).total_seconds()
        return 0.0


class Sentinex:
    """Main Sentinex scanner class"""
    
    # Supported hash algorithms
    SUPPORTED_ALGORITHMS = {
        'md5': hashlib.md5,
        'sha1': hashlib.sha1,
        'sha256': hashlib.sha256,
        'sha512': hashlib.sha512
    }
    
    # Default malware hash database (sample hashes for demonstration)
    DEFAULT_MALWARE_HASHES = {
        'sha256': {
            'ef3cb3f3d3c5d3e3f3g3h3i3j3k3l3m3n3o3p3q': 'Trojan.Generic.Sample',
            'a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0': 'Malware.Test.Hash',
            '356a192b7913b04c54574d18c28d46e6395428ab': 'Test.Malware.SHA256',
            'da39a3ee5e6b4b0d3255bfef95601890afd80709': 'Empty.File.Hash'
        },
        'md5': {
            'd41d8cd98f00b204e9800998ecf8427e': 'Empty.File.MD5',
            '5d41402abc4b2a76b9719d911017c592': 'Test.Hash.MD5'
        },
        'sha1': {
            'da39a3ee5e6b4b0d3255bfef95601890afd80709': 'Empty.File.SHA1',
            '356a192b7913b04c54574d18c28d46e6395428ab': 'Test.Hash.SHA1'
        }
    }
    
    def __init__(self, log_file: str = DEFAULT_LOG_FILE):
        self.malware_hashes = self.DEFAULT_MALWARE_HASHES.copy()
        self.results = ScanResults()
        self.logger = self._setup_logging(log_file)
        self._load_hash_database()
        
    def _setup_logging(self, log_file: str) -> logging.Logger:
        """Setup logging configuration"""
        logger = logging.getLogger('Sentinex')
        logger.setLevel(logging.DEBUG)
        
        # Clear existing handlers
        logger.handlers.clear()
        
        # File handler
        file_handler = logging.FileHandler(log_file, mode='w', encoding='utf-8')
        file_handler.setLevel(logging.DEBUG)
        
        # Console handler for errors
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.ERROR)
        
        # Formatter
        formatter = logging.Formatter(
            '%(asctime)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        
        file_handler.setFormatter(formatter)
        console_handler.setFormatter(formatter)
        
        logger.addHandler(file_handler)
        logger.addHandler(console_handler)
        
        return logger
        
    def _load_hash_database(self):
        """Load malware hash database from file"""
        try:
            if os.path.exists(HASH_DATABASE_FILE):
                with open(HASH_DATABASE_FILE, 'r', encoding='utf-8') as f:
                    loaded_hashes = json.load(f)
                    # Merge with default hashes
                    for algo, hashes in loaded_hashes.items():
                        if algo in self.malware_hashes:
                            self.malware_hashes[algo].update(hashes)
                        else:
                            self.malware_hashes[algo] = hashes
                            
                self.logger.info(f"Loaded hash database from {HASH_DATABASE_FILE}")
        except Exception as e:
            self.logger.warning(f"Could not load hash database: {e}")
            
    def _save_hash_database(self):
        """Save current malware hash database to file"""
        try:
            with open(HASH_DATABASE_FILE, 'w', encoding='utf-8') as f:
                json.dump(self.malware_hashes, f, indent=2)
            self.logger.info(f"Saved hash database to {HASH_DATABASE_FILE}")
        except Exception as e:
            self.logger.error(f"Could not save hash database: {e}")
            
    def add_malware_hashes(self, hashes: List[str], algorithm: str = 'sha256', threat_name: str = 'Unknown'):
        """Add new malware hashes to the database"""
        if algorithm not in self.malware_hashes:
            self.malware_hashes[algorithm] = {}
            
        added_count = 0
        for hash_value in hashes:
            if hash_value and hash_value not in self.malware_hashes[algorithm]:
                self.malware_hashes[algorithm][hash_value] = threat_name
                added_count += 1
                
        self._save_hash_database()
        return added_count
        
    def compute_file_hash(self, file_path: Path, algorithm: str) -> Optional[str]:
        """Compute hash of a file"""
        if algorithm not in self.SUPPORTED_ALGORITHMS:
            raise ValueError(f"Unsupported algorithm: {algorithm}")
            
        try:
            hasher = self.SUPPORTED_ALGORITHMS[algorithm]()
            
            with open(file_path, 'rb') as f:
                # Read file in chunks to handle large files efficiently
                while chunk := f.read(8192):
                    hasher.update(chunk)
                    
            return hasher.hexdigest()
            
        except Exception as e:
            self.logger.error(f"Failed to compute hash for {file_path}: {e}")
            return None
            
    def check_file_hash(self, file_path: Path, algorithm: str) -> bool:
        """Check if file hash matches known malware"""
        try:
            if not file_path.is_file():
                self.logger.warning(f"Skipped (not a file): {file_path}")
                self.results.skipped_files += 1
                return False
                
            file_hash = self.compute_file_hash(file_path, algorithm)
            
            if file_hash is None:
                self.results.add_error(str(file_path), "Failed to compute hash")
                return False
                
            self.results.scanned_files += 1
            
            # Check against malware database
            if algorithm in self.malware_hashes and file_hash in self.malware_hashes[algorithm]:
                threat_name = self.malware_hashes[algorithm][file_hash]
                self.results.add_detection(str(file_path), file_hash, algorithm, threat_name)
                self.logger.critical(f"MALWARE DETECTED: {file_path} ({threat_name}) - Hash: {file_hash}")
                return True
            else:
                self.results.clean_files += 1
                self.logger.info(f"Clean: {file_path}")
                return False
                
        except Exception as e:
            error_msg = f"Scan error: {str(e)}"
            self.results.add_error(str(file_path), error_msg)
            self.logger.error(f"Error scanning {file_path}: {e}")
            return False
            
    def get_scannable_files(self, directory: Path, extensions: Optional[Set[str]] = None) -> List[Path]:
        """Get list of files to scan"""
        files = []
        
        # Default extensions to scan if none specified
        if extensions is None:
            extensions = {'.exe', '.dll', '.bat', '.cmd', '.scr', '.pif', '.com', '.jar', '.zip', '.rar'}
            
        try:
            for item in directory.rglob('*'):
                if item.is_file():
                    if not extensions or item.suffix.lower() in extensions or '*' in extensions:
                        files.append(item)
                        
        except PermissionError as e:
            self.logger.warning(f"Permission denied accessing {directory}: {e}")
            
        return files
        
    def scan_directory(self, directory: str, algorithm: str = 'sha256', 
                      max_workers: int = 4, extensions: Optional[Set[str]] = None) -> ScanResults:
        """Scan directory for malware"""
        directory_path = Path(directory)
        
        if not directory_path.exists():
            raise FileNotFoundError(f"Directory not found: {directory}")
            
        if not directory_path.is_dir():
            raise NotADirectoryError(f"Not a directory: {directory}")
            
        self.logger.info(f"Starting scan of {directory} using {algorithm}")
        self.results = ScanResults()
        self.results.start_time = datetime.now()
        
        # Get list of files to scan
        print(f"{colorize('🔍 Discovering files...', Colors.CYAN)}")
        files_to_scan = self.get_scannable_files(directory_path, extensions)
        self.results.total_files = len(files_to_scan)
        
        if self.results.total_files == 0:
            print(f"{colorize('No files found to scan.', Colors.YELLOW)}")
            return self.results
            
        print(f"{colorize(f'Found {self.results.total_files} files to scan', Colors.GREEN)}")
        
        # Initialize progress bar
        progress = ProgressBar(self.results.total_files)
        
        # Scan files with thread pool
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_file = {
                executor.submit(self.check_file_hash, file_path, algorithm): file_path 
                for file_path in files_to_scan
            }
            
            for future in as_completed(future_to_file):
                progress.update()
                
        self.results.end_time = datetime.now()
        self.logger.info(f"Scan completed. Results: {self.results.infected_files} threats, {self.results.clean_files} clean")
        
        return self.results
        
    def generate_report(self, output_file: str = DEFAULT_REPORT_FILE):
        """Generate detailed scan report"""
        report = {
            'scan_info': {
                'version': VERSION,
                'start_time': self.results.start_time.isoformat() if self.results.start_time else None,
                'end_time': self.results.end_time.isoformat() if self.results.end_time else None,
                'duration_seconds': self.results.get_duration(),
            },
            'statistics': {
                'total_files': self.results.total_files,
                'scanned_files': self.results.scanned_files,
                'clean_files': self.results.clean_files,
                'infected_files': self.results.infected_files,
                'skipped_files': self.results.skipped_files,
                'errors': self.results.errors
            },
            'detections': self.results.malware_detections,
            'errors': self.results.scan_errors
        }
        
        try:
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(report, f, indent=2, ensure_ascii=False)
            self.logger.info(f"Report saved to {output_file}")
        except Exception as e:
            self.logger.error(f"Failed to save report: {e}")


def print_banner():
    """Display application banner"""
    banner = f"""
{colorize('╔══════════════════════════════════════════════════════════════════════╗', Colors.BRIGHT_CYAN)}
{colorize('║', Colors.BRIGHT_CYAN)}  {colorize('🛡️  Sentinex', Colors.BOLD + Colors.BRIGHT_WHITE)} {colorize('- Advanced Malware Detection Scanner', Colors.WHITE)}                   {colorize('║', Colors.BRIGHT_CYAN)}        
{colorize('║', Colors.BRIGHT_CYAN)}  {colorize(f'Version {VERSION}', Colors.DIM)} {' ' * (56 - len(f'Version {VERSION}'))}           {colorize('║', Colors.BRIGHT_CYAN)}      
{colorize('║', Colors.BRIGHT_CYAN)}  {colorize('Powered by cryptographic hash analysis', Colors.DIM)} {' ' * (27)}  {colorize('║', Colors.BRIGHT_CYAN)}
{colorize('╚══════════════════════════════════════════════════════════════════════╝', Colors.BRIGHT_CYAN)}
"""
    print(banner)


def print_scan_summary(results: ScanResults):
    """Print detailed scan summary"""
    duration = results.get_duration()
    
    print(f"\n{colorize('📊 SCAN SUMMARY', Colors.BOLD + Colors.BRIGHT_WHITE)}")
    print(f"{colorize('═' * 50, Colors.CYAN)}")
    
    # Statistics
    print(f"{colorize('Total Files:', Colors.BOLD)} {results.total_files:,}")
    print(f"{colorize('Scanned:', Colors.BOLD)} {results.scanned_files:,}")
    print(f"{colorize('Clean:', Colors.GREEN)} {results.clean_files:,}")
    print(f"{colorize('Infected:', Colors.BRIGHT_RED)} {results.infected_files:,}")
    print(f"{colorize('Skipped:', Colors.YELLOW)} {results.skipped_files:,}")
    print(f"{colorize('Errors:', Colors.RED)} {results.errors:,}")
    print(f"{colorize('Duration:', Colors.BOLD)} {duration:.2f} seconds")
    
    if results.infected_files > 0:
        print(f"\n{colorize('🚨 THREATS DETECTED:', Colors.BOLD + Colors.BRIGHT_RED)}")
        for detection in results.malware_detections:
            print(f"  {colorize('•', Colors.RED)} {detection['file_path']}")
            print(f"    {colorize('Threat:', Colors.RED)} {detection['threat_name']}")
            print(f"    {colorize('Hash:', Colors.DIM)} {detection['hash'][:16]}...")
    else:
        print(f"\n{colorize('✅ No threats detected!', Colors.BRIGHT_GREEN)}")


def create_parser():
    """Create argument parser"""
    
    description = f"""
{colorize('Sentinex', Colors.BOLD)} is an advanced malware detection scanner that uses
cryptographic hash analysis to identify known malicious files.

{colorize('Features:', Colors.BOLD)}
  • Multi-algorithm hash support (MD5, SHA1, SHA256, SHA512)
  • Multi-threaded scanning for improved performance
  • Extensible malware hash database
  • Detailed JSON reporting
  • Real-time progress tracking
  • Professional logging system

{colorize('Security Note:', Colors.YELLOW)}
This tool identifies files based on known malware signatures. It should be used
as part of a comprehensive security strategy alongside real-time antivirus protection.
"""
    
    epilog = f"""
{colorize('Examples:', Colors.BOLD)}
  %(prog)s scan -d "/path/to/scan"                    Basic directory scan
  %(prog)s scan -d "C:\\Users" -a sha256 -t 8        Scan with 8 threads using SHA256
  %(prog)s scan -d "/tmp" -e .exe .dll .bat         Scan specific file types
  %(prog)s update --add-hash hash1 hash2            Add malware hashes
  %(prog)s info                                      Show scanner information

{colorize('Author:', Colors.DIM)} {AUTHOR}
{colorize('Version:', Colors.DIM)} {VERSION}

For updates and documentation: https://github.com/Sentinex/scanner
"""
    
    parser = argparse.ArgumentParser(
        prog='Sentinex',
        description=description,
        epilog=epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        add_help=False
    )
    
    # Global arguments
    parser.add_argument('-h', '--help', action='help', help='Show this help message and exit')
    parser.add_argument('--version', action='version', version=f'Sentinex {VERSION}')
    parser.add_argument('--no-color', action='store_true', help='Disable colored output')
    
    # Create subparsers
    subparsers = parser.add_subparsers(dest='command', title='Commands', help='Available commands')
    
    # Scan command
    scan_parser = subparsers.add_parser('scan', help='🔍 Scan directory for malware')
    scan_parser.add_argument('-d', '--directory', required=True, help='Directory to scan')
    scan_parser.add_argument('-a', '--algorithm', default='sha256', 
                           choices=Sentinex.SUPPORTED_ALGORITHMS.keys(),
                           help='Hash algorithm to use (default: sha256)')
    scan_parser.add_argument('-t', '--threads', type=int, default=4, 
                           help='Number of threads for scanning (default: 4)')
    scan_parser.add_argument('-e', '--extensions', nargs='+', 
                           help='File extensions to scan (default: common executable types)')
    scan_parser.add_argument('-o', '--output', default=DEFAULT_REPORT_FILE,
                           help='Output file for detailed report')
    scan_parser.add_argument('--log', default=DEFAULT_LOG_FILE,
                           help='Log file path')
    
    # Update command
    update_parser = subparsers.add_parser('update', help='🔄 Update malware hash database')
    update_parser.add_argument('--add-hash', nargs='+', required=True,
                             help='Add malware hashes to database')
    update_parser.add_argument('-a', '--algorithm', default='sha256',
                             choices=Sentinex.SUPPORTED_ALGORITHMS.keys(),
                             help='Hash algorithm for new hashes')
    update_parser.add_argument('--threat-name', default='User.Added.Hash',
                             help='Threat name for new hashes')
    
    # Info command
    info_parser = subparsers.add_parser('info', help='ℹ️ Show scanner information')
    
    return parser


def main():
    """Main application entry point"""
    
    # Parse arguments first to check for --no-color
    parser = create_parser()
    
    if len(sys.argv) == 1:
        print_banner()
        parser.print_help()
        sys.exit(0)
        
    args = parser.parse_args()
    
    # Set NO_COLOR environment variable if requested
    if hasattr(args, 'no_color') and args.no_color:
        os.environ['NO_COLOR'] = '1'
    
    # Show banner
    print_banner()
    
    try:
        if args.command == 'scan':
            # Initialize scanner
            scanner = Sentinex(args.log)
            
            # Prepare extensions set
            extensions = None
            if args.extensions:
                extensions = {ext if ext.startswith('.') else f'.{ext}' for ext in args.extensions}
                extensions.add('*')  # Allow all if specific extensions provided
            
            print(f"{colorize('🎯 Target Directory:', Colors.BOLD)} {args.directory}")
            print(f"{colorize('🔢 Hash Algorithm:', Colors.BOLD)} {args.algorithm.upper()}")
            print(f"{colorize('🧵 Threads:', Colors.BOLD)} {args.threads}")
            print(f"{colorize('📝 Log File:', Colors.BOLD)} {args.log}")
            print()
            
            # Perform scan
            results = scanner.scan_directory(
                args.directory, 
                args.algorithm, 
                args.threads,
                extensions
            )
            
            # Print summary
            print_scan_summary(results)
            
            # Generate report
            scanner.generate_report(args.output)
            print(f"\n{colorize('📄 Detailed report saved to:', Colors.BOLD)} {args.output}")
            
        elif args.command == 'update':
            scanner = Sentinex()
            added_count = scanner.add_malware_hashes(
                args.add_hash, 
                args.algorithm, 
                args.threat_name
            )
            print(f"{colorize('✅ Successfully added', Colors.GREEN)} {added_count} {colorize('new malware hashes', Colors.GREEN)}")
            
        elif args.command == 'info':
            print(f"{colorize('🛠️  Scanner Information:', Colors.BOLD)}")
            print(f"Version: {VERSION}")
            print(f"Supported Algorithms: {', '.join(Sentinex.SUPPORTED_ALGORITHMS.keys())}")
            print(f"Hash Database: {HASH_DATABASE_FILE}")
            print(f"Default Log File: {DEFAULT_LOG_FILE}")
            print(f"Default Report File: {DEFAULT_REPORT_FILE}")
            
            # Show hash database stats
            scanner = Sentinex()
            total_hashes = sum(len(hashes) for hashes in scanner.malware_hashes.values())
            print(f"Known Malware Hashes: {total_hashes:,}")
            
        else:
            print(f"{colorize('Error: No command specified', Colors.RED)}")
            parser.print_help()
            sys.exit(1)
            
    except KeyboardInterrupt:
        print(f"\n{colorize('🛑 Scan interrupted by user', Colors.YELLOW)}")
        sys.exit(1)
    except Exception as e:
        print(f"{colorize('❌ Error:', Colors.RED)} {str(e)}")
        sys.exit(1)


if __name__ == "__main__":
    main()